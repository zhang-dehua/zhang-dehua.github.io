---
layout: post
title: 并行计算-MPI编程
description: 描述
date: 2021-04-23
tags: 编程；高性能计算
---

### 关于MPI

关于MPI的定义可以从三个角度做出描述：

- MPI是一个库，而不是一门编程语言。MPI库中包含了可以被Fortran/C//C++调用的一系列子例程和函数，MPI库函数/过程遵守所有对库函数/过程的调用规则，和一般的函数/过程没有什么区别 。MPI程序的源代码被C或Fortran的编译器编译之后，再与与MPI库链接，就生成了可执行的MPI程序。
- MPI是一种标准或规范的代表，而不特指某一个对它的具体实现。迄今为止所有的并行计算机制造商都提供对MPI的支持，可以在网上免费得到MPI在不同并行计算机上的实现，一个正确的MPI程序可以不加修改地在所有的并行机上运行 。
- MPI是一种消息传递的编程模型。MPI库虽然很庞大，但是它的最终目的是完成进程间的通信。 

### MPI程序的运行过程

一个MPI程序的运行过程可以概括为：

首先，将MPI程序源代码编译之后生成可执行的MPI程序；接下来，向操作系统提交MPI可执行程序，操作系统再将可执行程序复制N份交给N个节点；然后，每个节点各自运行自己的MPI程序，运行过程会调用MPI库函数/过程，得到该节点上的进程号my_id，根据进程号号程序的执行情况不同，并适时地进行不同节点间的消息传递，以完成并行的任务。

### 一个最简单的MPI程序

下面是一个简单的Fortran语言的MPI程序：

```fortran
PROGRAM hello_world
    USE MPI
    IMPLICIT NONE
	! or the older form
    ! IMPLICIT NONE
    ! INCLUDE 'mpif.h'
	

    INTEGER :: my_id, proc_num, ierr
    
    call MPI_INIT(ierr)
    call MPI_COMM_RANK(MPI_COMM_WORLD,my_id,ierr)
    call MPI_COMM_SIZE(MPI_COMM_WORLD,proc_num,ierr)
    WRITE(*,*) "Hello  World! My id is :", my_id
    CALL MPI_FINALIZE(ierr)

END PROGRAM
```

### 基本的MPI函数（子例程）

MPI有上百个可调用的函数（子例程），具体调用语法可查阅 [Open MPI 的说明文档](https://www.open-mpi.org/doc/v4.1/)，但是理论上讲 MPI所有的通信功能可以用它的6个基本的函数（子例程）来实现。以下以Fortran语言的MPI实现为例，说明MPI的6个基本的函数（子例程）：

1. MPI初始化

```fortran
CALL MPI_INIT(ierr)
! OUT INTEGER :: ierr -返回值为0表示成功，返回值为非0表示出错
```

2. MPI结束

```fortran
CALL MPI_FINALIZE(ierr)
! OUT INTEGER :: ierr
```

3. 得到当前进程在给定通信域（也叫通信子）中的编号

```fortran
call　MPI_COMM_RANK(comm,my_id,ierr)
! IN  INTEGER :: comm -给定的通信域，可以为MPI预定义的通信域MPI_COMM_WORLD（包含所有进程），也可以为其他自定义通信域
! OUT INTEGER :: my_id -当前节点的进程号
! OUT INTEGER :: ierr -给定的通信域
```

4. 得到给定通信域内的进程数

```fortran
call　MPI_COMM_SIZE(comm,proc_num,ierr)
! IN  INTEGER :: comm -给定的通信域
! OUT INTEGER :: proc_num -给定通信域内的进程数
! OUT INTEGER :: ierr
```

5. 消息发送

```fortran
call　MPI_SEND(buf,count,datatype,dest,tag,comm,ierr)
! IN  <TYPE>  :: buf -发送数据的起始地址
! IN  INTEGER :: count -发送数据的个数
! IN  <handle> :: data_type -发送数据的类型，可以是MPI预定义的数据类型，也可以是用户的自定义的新的数据结构（非连续）
! IN  INTEGER :: dest -目的进程的编号
! IN  INTEGER :: tag -此次发送的标签
! IN  INTEGER :: comm -给定的通信域
! OUT INTEGER :: ierr
```

说明：MPI_SEND将count个datatype数据类型的数据发送到目的进程， 目的进程在通信域中的标识号是dest，本次发送的消息标志是tag，使用这一标志就可以把本次发送的消息和本进程向同一目的进程发送的其它消息区别开来 ， 其中datatype数据类型可以是MPI的预定义类型 也可以是用户自定义的类型 （后文介绍）。

6. 消息接收

```fortran
call　MPI_RECV(buf,count,datatype,source,tag,comm,status,ierr)
! OUT <TYPE>  :: buf -接受数据的起始地址
! IN  INTEGER :: count -接受数据的个数
! IN  <handle> :: data_type -接收数据的类型，可以是MPI预定义的数据类型，也可以是用户的自定义的新的数据结构（非连续）
! IN  INTEGER :: source -所接受数据的进程的编号，可以为MPI_ANY_SOURCE（MPI预定义常量），用以匹配任意消息来源
! IN  INTEGER :: tag -此次接收的标签，可以为MPI_ANY_TAG（MPI预定义常量）用以匹配任意消息标签
! IN  INTEGER :: comm -给定的通信域
! OUT INTEGER :: status(MPI_STATUS_SIZE) 返回状态和调试信息 
! OUT INTEGER :: ierr
```

说明：MPI_RECV从指定的进程source接收消息，发送消息的数据类型datatype和消息标识tag要与接收进程指定的datatype和tag相一致，接收消息的起始地址为buf，接收消息的长度必须不小于发送消息的长度，这是因为如果接收到的数据过大，接收缓冲区会发生溢出错误，如果一个长度短于count的消息到达，那么只有相应于这个消息的那些地址被修改，count可以是零，这种情况下消息的数据部分是空的，其中datatype数据类型可以是MPI的预定义类型 也可以是用户自定义的类型 （后文介绍），status是包含MPI_STATUS_SIZE个整型的数组，status(MPI_SOURCE)，status(MPI_TAT)和status(MPI_ERROR)分别表示发送数据的进程标识，发送数据使用tag标识和该接收操作返回的错误代码  。